### 【题目】[剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)
请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

示例 1：
	输入：s = "We are happy."
	输出："We%20are%20happy."

限制：
0 <= s 的长度 <= 10000

### 【解题思路1】[s.replace() 或者 StringBuilder](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/2chong-jie-fa-replacebian-li-by-xiao-bai-323/)

```java
class Solution {
    public String replaceSpace(String s) {
        return s.replace(" ","%20");
    }
}
```

```java
class Solution {
    public String replaceSpace(String s) {
        StringBuilder newS = new StringBuilder();
        for (Character tmp: s.toCharArray()) {
            newS.append(tmp ==' ' ? "%20" : tmp);  // 建议使用三目表达式。相等于if else
        }
        return newS.toString();
    }
}
```

### 【解题思路2】char数组：辅助数组

```java
class Solution {
    public String replaceSpace(String s) {
        int length = s.length();
        char[] array = new char[length * 3];
        int size = 0;
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            if (c == ' ') {
                array[size++] = '%';
                array[size++] = '2';
                array[size++] = '0';
            } else {
                array[size++] = c;
            }
        }
        String newStr = new String(array, 0, size);
        return newStr;
    }
}
```

### 【解题思路3】char数组：原数组上修改
在原数组上进行改动，用快慢指针确定最后的长度
如果溢出部分就不要了，就和[1089. 复写零](https://blog.csdn.net/XunCiy/article/details/106144746)的快慢指针解法相似



### 【题目】[1089. 复写零](https://leetcode-cn.com/problems/duplicate-zeros/)
给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。
注意：请不要在超过该数组长度的位置写入元素。
要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。

示例 1：

	输入：[1,0,2,3,0,4,5,0]
	输出：null
	解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
示例 2：
	输入：[1,2,3]
	输出：null
	解释：调用函数后，输入的数组将被修改为：[1,2,3]

提示：
1 <= arr.length <= 10000
0 <= arr[i] <= 9

### 【解题思路1】快慢指针

```java
class Solution {
    public void duplicateZeros(int[] arr) {
        int len = arr.length;
        int fast = 0, slow = 0; //i是快指针，j是慢指针
        while(fast < len){
            if(arr[slow] == 0){
                fast++;
            }
            fast++;
            slow++;
        }
        slow--; //要复制的最后一个数的下标，这之后的数溢出
        if(fast != slow){ //有0
            int i = len - 1;
            //处理最后一个元素是0，复制这个0溢出的情况，如[1,0,2,3,0,0,5,0]
            if(fast == len + 1){
                arr[i] = 0;
                i--;
                slow--;
            }
            while(slow >= 0){
                if(arr[slow] == 0){
                    arr[i] = 0;
                    arr[i - 1] = 0;
                    i--;
                }else{
                    arr[i] = arr[slow];
                }
                i--;
                slow--;
            }
        }
    }
}
```

```java
class Solution {
    public void duplicateZeros(int[] arr) {
        int n = arr.length;
        int i = 0, j = 0;
        while (j < n) {
            if (arr[i] == 0) j++;
            i++;
            j++;
        }
        // 结束循环时，i和j都在遍历结束为止的下一个为止
        i--;    // i 回到最后一次合法的位置
        j--;    // j 同理，但 j 仍可能等于 n（例如输入 [0]）
        while (i >= 0) {
            if (j < n) arr[j] = arr[i];
            if (arr[i] == 0) arr[--j] = arr[i];
            i--;
            j--;
        }
    }
}

```

### 【解题思路2】复制数组 - 辅助数组

```java
class Solution {
	public void duplicateZeros(int[] arr) {
        int[] temp = Arrays.copyOf(arr, arr.length);//复制原数组到temp
        int index = 0;//指向temp的数组下标
        for(int i = 0; i < arr.length; i++){//修改原数组（只要把原数组修改完就行，temp数组可能未遍历完）
            arr[i] = temp[index];//将temp[index]的值直接给arr[i]
            if(temp[index++] == 0 && i+1 < arr.length){//如果temp[index]==0的话，考虑补0
                arr[i+1] = 0;
                i++;
            }
        } 
    }
}
```