# 牛客IOS面经整理

## 小结（主要针对字节）

计网：TCP/UDP/IP、HTTP、DNS等基础通信原理

OS：进程、线程、锁

数据结构：几种排序算法、B/B+树

C++/JAVA语言基础：hashmap原理

IOS相关/其他：MVC/MVVM、GET和POST、Socket通信原理、JSON数据传输、有web开发经验的优先

## 计网

### HTTP、HTTPS

1. [HTTP常见状态码](https://blog.csdn.net/laishaohe/article/details/79052085)

   200 – 请求成功

   301 – 资源(网页等)被永久转移到其它URL

   404 – 请求的资源(网页等)不存在

   500 – 内部服务器错误

2. HTTP和HTTPS的区别，HTTPS加密过程（https是如何安全的，用到了什么加密算法，怎么获取私钥），中间URL怎么变，HTTP的长连接和短连接，HTTP头部有哪些内容，http2.0和http1.0区别,如果没有http2.0，怎么解决短连接问题

**HTTP**

[超文本传输协议](https://baike.baidu.com/item/超文本传输协议/8535513)（HTTP，HyperText Transfer Protocol)是[互联网](https://baike.baidu.com/item/互联网)上应用最为广泛的一种[网络协议](https://baike.baidu.com/item/网络协议/328636)。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。

① 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。

② 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。

**HTTPS**

是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 **SSL**。SSL 协议位于 [TCP/IP 协议](https://baike.baidu.com/item/TCP/IP协议)与各种应用层协议之间，为[数据通讯](https://baike.baidu.com/item/数据通讯)提供安全支持。SSL 协议可分为两层：**SSL 记录协议（SSL Record Protocol）**，它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

<img src="https://img-blog.csdnimg.cn/20200707084720409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />

**HTTPS设计目标**

1. **数据保密性**：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么 。

2. **数据完整性**：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。

3. **身份校验安全性**：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 。

**HTTP 与 HTTPS的区别，HTTPS相对于HTTP的改进**

1. HTTPS 协议需要到 **CA （Certificate Authority，证书颁发机构）申请证书**，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)

2. HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 **SSL 加密传输协议**。

3. HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是**80**，后者是**443**。

4. HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

**关于CA**

- 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。**这套证书其实就是一对公钥和私钥。**

- 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。

- **客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。**

**双向的身份认证**

[客户端](https://baike.baidu.com/item/客户端/101081)和[服务端](https://baike.baidu.com/item/服务端/6492316)在传输数据之前，会通过基于[X.509](https://baike.baidu.com/item/X.509/2817050)证书对双方进行身份认证 。具体过程如下：

- 客户端发起 SSL 握手消息给服务端要求连接。

- 服务端将证书发送给客户端。

- 客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。

- 服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的[公钥](https://baike.baidu.com/item/公钥/6447788)，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。

**数据传输的机密性**

客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端，其中包含自己支持的**非对成加密的密钥交换算法 ( 一般是[RSA](https://baike.baidu.com/item/RSA/210678))，数据签名摘要算法 ( 一般是[SHA](https://baike.baidu.com/item/SHA/9533316)或者[MD5](https://baike.baidu.com/item/MD5/212708)) ，加密传输数据的对称加密算法 ( 一般是[DES](https://baike.baidu.com/item/DES/210508))**，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。**客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。**

**防止重放攻击**

SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。

可以看到，鉴于[电子商务](https://baike.baidu.com/item/电子商务/98106)等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了[非对称加密](https://baike.baidu.com/item/非对称加密/9874417)的安全性和[对称加密](https://baike.baidu.com/item/对称加密/2152944)的快速性。

**客户端解析证书**

这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个对称加密密钥，然后用公钥对该密钥进行非对称加密。

**传送加密信息**

这部分传送的是用公钥加密后的对称加密密钥，目的就是让服务端得到这个密钥，以后客户端和服务端的通信就可以通过这个密钥来进行加密解密了。

**服务端解密信息**

服务端用非对称加密算法里的私钥解密后，得到了客户端传过来的对称加密算法的私钥，然后把之后传输的内容通过该值进行对称加密。

**为什么用非对称加密协商对称加密密钥**

对称加密的特点：对称密码体制中只有一种密钥，并且是非公开的。如果要解密就得让对方知道密钥，所以想要保证其安全性就要保证密钥的安全。

非对称加密的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了，这样安全性就大了很多。

非对称加密公钥和私钥的使用方法：(1) 公钥加密私钥解密。(2) 私钥做数字签名，公钥验证。

**HTTPS 的连接的详细过程**

![img](https://img-blog.csdn.net/20180709141944471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Mjg5ODE1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

① 客户端的[浏览器](https://baike.baidu.com/item/浏览器)向服务器发送请求，并传送客户端 SSL 协议的[版本号](https://baike.baidu.com/item/版本号)，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。

② 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。

③ 客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行[服务器证书](https://baike.baidu.com/item/服务器证书)的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 "发行者的数字签名"，服务器证书上的[域名](https://baike.baidu.com/item/域名)是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。

④ 用户端随机产生一个用于通讯的 "对称密码"，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。

⑤ 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。

⑥ 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA 是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主[通讯密码](https://baike.baidu.com/item/通讯密码)（客户端也将通过同样的方法产生相同的主通讯密码）。

⑦ 服务器和客户端用相同的对称加密密钥，[对称密钥](https://baike.baidu.com/item/对称密钥)用于 SSL 协议的安全[数据通讯](https://baike.baidu.com/item/数据通讯)的加解密[通讯](https://baike.baidu.com/item/通讯)。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。

⑧ [客户端](https://baike.baidu.com/item/客户端)向[服务器](https://baike.baidu.com/item/服务器)端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为[对称密钥](https://baike.baidu.com/item/对称密钥)，同时通知服务器客户端的握手过程结束。

⑨ 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。

⑩ SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。

### DNS

1. [DNS缓存](https://blog.csdn.net/yonggeit/article/details/88175022)
2. DNS域名解析过程，接收到DNS查询结果之后还做了什么
3. IP地址的分类清楚吗？子网是怎么划分的，什么是子网掩码？
4. 代理服务器的工作原理是怎样的？代理和网关有什么区别？
5. 了解cookie和session吗，二者有什么区别？
6. 浏览器输入百度地址，中间具体访问过程是怎么样的，一次网页请求的完整过程，DNS的详细过程-->从本地HOST讲到根域名/顶级域名



### TCP/UDP

1. TCP四层模型，每层常见协议

   <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" width="450"/>

   ![img](https://img-blog.csdnimg.cn/20190802001835308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lhbnNreTU4Njg1,size_16,color_FFFFFF,t_70)

11. ARP协议，ARP在网络层

    每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 **IP 地址到 MAC 地址的映射表**。

    如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过**广播**的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

12. TCP和UDP（补充一下具体的字段信息）

    - 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

    - 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

13. TCP拥塞机制，滑动窗口，流量控制如何实现

14. TCP怎么保证可靠，如何用UDP设计一个可靠连接

    checksum、ack、sequence number、定时器

15. TCP三次握手，四次握手

16. 什么是负载均衡，知道典型的负载均衡算法吗？


## OS

1. [进程通信](https://github.com/Sophia-fez/SE-IOS-Notes/blob/master/%E8%AE%A1%E7%BD%91%20OS/%E8%AE%A1%E7%BD%91.md)

   **（这是啥要查一下）文件通信->数据库通信->单例模式通信->redis通信**

   - 进程同步：控制多个进程按一定顺序执行
   - 进程通信：进程间传输信息

   进程通信的五种方式：管道、FIFO、消息队列、信号量、共享存储、套接字

   - 管道：速度慢，容量有限，只有父子进程能通讯    

   - FIFO：任何进程间都能通讯，但速度慢    

   - 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    

   - 信号量：不能传递复杂消息，只能用来同步    

   - 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

   消息队列对比管道FIFO的优点：

    - 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
    - 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
    - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

2. 进程和线程的区别

   进程：资源分配的基本单位，一个进程中可以有多个线程，它们共享进程资源

   线程：独立调度的基本单位

   - 拥有资源
     进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

   - 调度
     线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

   - 系统开销
     由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

   - 通信方面
     线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

3. [为什么有进程还要线程](https://blog.csdn.net/N1314N/article/details/93711245)

   减少程序在并发执行时所付出的时空开销，提高并发性

4. **线程安全的方式有哪些，多线程是什么**

5. **锁，知道的锁和用法**，程序锁，乐观锁，悲观锁，单线程锁，共享锁，非共享锁还有什么锁

6. 进程的几种状态以及什么条件下可以转换

   <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" width="500"/> </div><br>

   - 就绪状态（ready）：等待被调度
- 运行状态（running）
   - 阻塞状态（waiting）：等待资源
   
   应该注意以下内容：

   - 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。
  
5. 死锁

   必要条件：互斥，占有和等待，不可抢占，环路等待

   处理方法：鸵鸟策略，死锁检测和恢复，死锁预防，死锁避免

6. 虚拟内存，段页式，段页式的好处



## 数据结构

1. B树B+树，红黑树
2. 排序算法
3. 数组与链表的区别

## C++/JAVA语言基础

1. 面向对象（封装，继承和多态）

2. hashmap的底层实现

3. [java实现线程同步的七种方法](https://www.cnblogs.com/cxxjohnson/p/8536257.html)

   同步方法
   同步代码块
   使用重入锁实现线程同步（ReentrantLock）
   使用特殊域变量(volatile)实现同步(每次重新计算，安全但并非一致)
   使用局部变量实现线程同步（ThreadLocal）以空间换时间
   使用原子变量实现线程同步(AtomicInteger(乐观锁))
   使用阻塞队列实现线程同步(BlockingQueue （常用）add(),offer(),put()

4. [C++ static关键字](https://www.cnblogs.com/__tudou__/p/11598140.html)

   static关键字主要起隐藏作用，static关键字在C\C++中都可以修饰内置类型变量、函数：

   面向过程设计中的static：静态全局变量、静态局部变量、静态函数
   面向对象的static关键字（类中的static关键字）：静态数据成员、静态成员函数

5. [指针和引用的区别](https://blog.csdn.net/l477918269/article/details/90233908)

   引用是别名，指针是地址。指针在运行时可以改变所指向的值，而引用一旦与某个对象绑定后就不再改变。

6. 面向对象六大原则

7. [堆栈](https://blog.csdn.net/yingms/article/details/53188974) 堆和栈的区别，他们都存什么内容，栈会溢出吗？什么情况下会溢出（待查）

   堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，队列优先,先进先出（FIFO—first in first out）。栈，先进后出(FILO—First-In/Last-Out)。

8. C++程序底层编译到运行的过程，代码到可执行文件的过程：预处理 编译 汇编 链接

9. 虚函数（待查）

10. python和C++的区别（待查）


## IOS

1. MVC、MVVM，详细讲一下MVC？MVC数据流通的关系？为什么实际上可以做到V直接到M但一般实际情况中却不去使用呢？

   **Model（模型）**：处理数据逻辑的部分。通常Model对象负责在数据库中存取数据。

   **View（视图）**：处理数据显示的部分。通常视图是依据模型数据创建的。

   **Controller（控制器）**：处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

   iOS中多数数据源视图控件（View）都有一个dataSource属性用于和控制器（Controller）交互，而数据来源一般会以数据模型（Model）的形式进行定义，View不直接和模型交互，而是通过Controller间接读取数据。

   ![img](https://bkimg.cdn.bcebos.com/pic/ac6eddc451da81cb26660e7e5066d01608243184?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

2. UITableView了解多少，cell能不能重用

   UITableView中每行数据都是一个UITableViewCell，UITableViewCell的内部有一个UIView控件（contentView，作为其他元素的父控件）、两个UILable控件（textLabel、detailTextLabel）、一个UIImage控件（imageView），分别用于容器、显示内容、详情和图片

   UITableView对于数据源控件除了代理还有一个数据源属性，通过它和外界进行数据交互。 对于UITableView设置完dataSource后需要实现

   ![img](http://www.cocoachina.com/cms/uploads/allimg/140922/4196_140922110101_1.png)

   ![img](http://www.cocoachina.com/cms/uploads/allimg/140922/4196_140922110109_1.png)

   支持**自定义UITableViewCell**，cell的复用，其中红色为可视区域，蓝色为屏幕外区域

   <img src="https://upload-images.jianshu.io/upload_images/1322498-28c8d3a2b8b8f00f.png?imageMogr2/auto-orient/strip|imageView2/2/w/290/format/webp" alt="img" style="zoom: 75%;" /><img src="https://upload-images.jianshu.io/upload_images/1322498-e02c571c469a729d.png?imageMogr2/auto-orient/strip|imageView2/2/w/325/format/webp" alt="img" style="zoom:75%;" /><img src="https://upload-images.jianshu.io/upload_images/1322498-05fb712b0dfa16ba.png?imageMogr2/auto-orient/strip|imageView2/2/w/326/format/webp" alt="img" style="zoom:75%;" />

   - 对于在 MVC 的定义中，view 层是不引用 model 层，view 和 model 是不相往来的
   - 一般开发中，在自定义 view 中增加一个 model 的属性，外接直接传个 model 来，在 view 中 model 的 set 方法里对 view 的控件赋值的代码，例如在自定义 UITableViewCell 时用的很多，此时 view 是直接引用了 model
   - **基于封装的思想，需要尽可能的复用代码，复用view，所以需要进行解耦，不依赖于某个特殊的 model。**另外，如果对于很特殊的 view，整个项目中没有什么重用的，可以按之前情况处理

### 其他

1. [GET和POST是HTTP请求的两种基本方法，区别](https://blog.csdn.net/ever_siyan/article/details/87935455) 

   GET把参数包含在URL中，POST通过request body传递参数

   GET产生一个TCP数据包；POST产生两个TCP数据包。

   GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

   POST方式的请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

2. 设计模式，单例模式（如何保证线程安全）

3. 知道哪些加密算法

4. 检验ca证书合法性是干啥的

